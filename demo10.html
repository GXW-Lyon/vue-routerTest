<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
  <title>Document</title>
</head>
<body>
  <!-- 导航守卫 -->
  <!-- router.beforeEach;
    当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待中。
    to:Route:即将要进入的目标路由对象。
    from:Route:当前导航正要离开的路由。
    next:Function:一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数。
        next():进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的);
        next(false):中端当前的导航。如果浏览器的URL改变了。那么URL地址会重置到from路由对应的地址。
        next('/'):或则next({path:'/'}):跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向next传递任意位置对象，且允许设置诸如replace:true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。
        next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。

        路由独享的守卫
        const router = new VueRouter({
          routes:[
          {
            path:'/foo',
            component:Foo,
            beforeEnter:(to,from,next)=>{}
          }]
        })

        在组件内的守卫
        beforeRouteEnter
        beforeRouteUpdate
        beforeRouteLeave
        
        const Foo={
          template:'',
          beforeRouteEnter(to,from,next){
            //在渲染该组件的对应路由被confirm前调用
            //不能获取组件实例this，因为当守卫执行前，组件实例还没被创建。
          }，
          beforeRouteUpdate(to,from,next){
            //在当前路由改变，但是该组件被复用时调用
            //举例来说，对于一个带有动态参数的路径/foo/:id,在/foo/1和/foo/2之间跳转的时候。由于会渲染同样的Foo组件，因此组件实例会被复用。可以访问组件实例this
          },
          beforeRouteLeave(to,from,next){
            //导航离开该组件的对应路由时调用。可以使用this
          }
        }

        beforeRouteEnter守卫不能访问this，但是可以通过传一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
        beforeRouteEnter(to,from,next){
          next(vm=>{
            //通过vm访问组件实例
          })
        }
        注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。

        beforeRouteUpdate (to, from, next) {
          // just use `this`
          this.name = to.params.name
          next()
        }

        beforeRouteLeave (to, from , next) {
          const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
          if (answer) {
            next()
          } else {
            next(false)
          }
        }
   -->


   <!--路由元信息 -->
   <!-- 
     定义路由的时候可以配置meta字段：
      const router = new VueRouter({
        routes:[
          {path:'/foo',component:Foo,
          children:[
            path:'bar',
            component:Bar,
            meta:{requiresAuth:true}
          ]
          }
        ]
      })
      首先，我们称呼routes配置中的每个路由对象为路由记录。路由记录可以是嵌套的，因此当一个匹配成功后，它可能匹配多个路由记录。
      一个路由匹配到的所有路由记录会暴露为$route对象的$route.matched数组。因此我们需要遍历$route.matched来检查路由记录中的meta字段。

      router.beforeEach((to, from, next) => {
        if (to.matched.some(record => record.meta.requiresAuth)) {
          // this route requires auth, check if logged in
          // if not, redirect to login page.
          if (!auth.loggedIn()) {
            next({
              path: '/login',
              query: { redirect: to.fullPath }
            })
          } else {
            next()
          }
        } else {
          next() // 确保一定要调用 next()
        }
      })
    -->
</body>
</html>